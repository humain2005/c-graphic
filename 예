다음은 파일로부터 block.jpg를 불러와 텍스처에 저장한 후, 사진이 화면에서 출력되어 색깔이 지속적으로 변하며 마우스를 쫓아오도록 설계한 코드입니다. 빈칸에 들어갈 알맞은 답을 적으시오(화면은 검은색)

#include <#1>
#include <cmath>

// HSV → RGB 변환 함수
sf::#2 HSVtoRGB(float H, float S, float V, sf::Uint8 A=255) {
    float C = V * S;
    float X = C * (1 - fabs(fmod(H / 60.f, 2) - 1));
    float m = V - C;
    float r, g, b;

    if (H < 60)       { r = C; g = X; b = 0; }
    else if (H < 120) { r = X; g = C; b = 0; }
    else if (H < 180) { r = 0; g = C; b = X; }
    else if (H < 240) { r = 0; g = X; b = C; }
    else if (H < 300) { r = X; g = 0; b = C; }
    else              { r = C; g = 0; b = X; }

    return sf::Color((r + m) * 255, (g + m) * 255, (b + m) * 255, A);
}

int main() {
    sf::RenderWindow window(sf::VideoMode(800, 600), "Follow Mouse & Rainbow Color");

    sf::Texture texture;
    if (!texture.#3("block.jpg"))   // [빈칸 1]
        return -1;

    sf::Sprite sprite(texture);
    sf::Vector2u size = texture.#4;
    sprite.setOrigin(size.x / 2.f, size.y / 2.f);

    sf::Vector2f position(window.getSize().x / 2.f, window.getSize().y / 2.f);
    sprite.setPosition(position);

    sf::Clock clock;
    float speed = 0.005f;

    while (#5) {   // [빈칸 2]
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                #6;
        }

        sf::Vector2f mousePos = static_cast<sf::Vector2f>(sf::Mouse::#6);
        position += (mousePos - position) * speed;
        sprite.setPosition(position);

        float hue = fmod(clock.getElapsedTime().asSeconds() * 60.f, 360.f);
        sf::Color color = HSVtoRGB(hue, 1.f, 1.f);
        sprite.setColor(color);

        #8(sf::Color::#8);
        window.draw(sprite);
        window.display();
    }

    return 0;
}

답
#1:SFML/Graphics.hpp
#2:Color
#3:loadFromFile
#4:getSize()
#5:window.isOpen
#6:window.close()
#7:getPosition(window)
#8:window.clear
#9:Black
